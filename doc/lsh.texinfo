\input texinfo          @c -*-texinfo-*-

@c %**start of header
@setfilename lsh.info
@settitle lsh
@c %**end of header

@documentencoding ISO-8859-1

@dircategory GNU Packages
@direntry
* LSH: (lsh).           Secure Shell and related utilities.
@end direntry

@set UPDATED-FOR 3.0

@c Latin-1 doesn't work with tex output.
@c Also look out for é characters.

@set AUTHOR Niels Möller
@ifinfo
Manual for LSH. This manual corresponds to @command{lsh} version
@value{UPDATED-FOR}. 

Copyright 2000, 2004, 2008, 2010, 2011 @value{AUTHOR}

Permission is granted to make and distribute verbatim
copies of this manual provided the copyright notice and
this permission notice are preserved on all copies.

@ignore
Permission is granted to process this file through TeX
and print the results, provided the printed document
carries a copying permission notice identical to this
one except for the removal of this paragraph (this
paragraph not being relevant to the printed manual).

@end ignore
Permission is granted to copy and distribute modified
versions of this manual under the conditions for
verbatim copying, provided also that the sections
entitled ``Copying'' and ``GNU General Public License''
are included exactly as in the original, and provided
that the entire resulting derived work is distributed
under the terms of a permission notice identical to this
one.

Permission is granted to copy and distribute
translations of this manual into another language,
under the above conditions for modified versions,
except that this permission notice may be stated in a
translation approved by the Free Software Foundation.

@end ifinfo

@titlepage
@sp 10
@c @center @titlefont{LSH Manual}

@title LSH Manual
@subtitle For @command{lsh} version @value{UPDATED-FOR}

@author @value{AUTHOR}

@c The following two commands start the copyright page.
@page
@vskip 0pt plus 1filll
Copyright @copyright{} 2000, 2004, 2008, 2010 @value{AUTHOR}

Permission is granted to make and distribute verbatim
copies of this manual provided the copyright notice and
this permission notice are preserved on all copies.

Permission is granted to copy and distribute modified
versions of this manual under the conditions for
verbatim copying, provided also that the sections
entitled ``Copying'' and ``GNU General Public License''
are included exactly as in the original, and provided
that the entire resulting derived work is distributed
under the terms of a permission notice identical to this
one.

Permission is granted to copy and distribute
translations of this manual into another language,
under the above conditions for modified versions,
except that this permission notice may be stated in a
translation approved by the Free Software Foundation.

@end titlepage

@contents

@ifnottex
@node     Top, Introduction, (dir), (dir)
@comment  node-name,  next,  previous,  up
@ifinfo
@top
@end ifinfo

This document describes @command{lsh} and related programs. The
@command{lsh} suite of programs is intended as a free replacement for
the @command{ssh} suite of programs. In turn, @command{ssh} was intended
as a secure replacement for the @command{rsh} and @command{rlogin}
programs for remote login over the Internet.

@command{lsh} is a component of the @acronym{GNU} system.

This manual explains how to use and hack @command{lsh}; it corresponds to
@command{lsh} version @value{UPDATED-FOR}.

@menu
* Introduction::                
* Installation::                
* Getting started::             
* Server configuration::        
* Invoking lsh::                
* Invoking lshd::               
* Files and environment variables::  
* Concept Index::               

@detailmenu
 --- The Detailed Node Listing ---

Introduction

* Threats::                     
* Features::                    
* Related techniques::          

Related programs and techniques

* ssh1::                        SSH version 1
* ssh2::                        SSH version 2
* tls::                         
* Kerberos::                    Kerberos
* ipsec::                       IP Sec

Getting started

* lsh-make-seed ::              Initializing the randomness generator
* lsh basics::                  Connection with lsh
* tcpip forwarding::            Forwarding @acronym{TCP/IP} ports
* lshd basics::                 Starting the lshd deamon
* public-key::                  Using public-keys
* sexp::                        Examining keys and other S-exp files
* Converting keys::             

Server configuration

* Configuration syntax::        
* Common options::              
* lshd configuration::          
* lshd-userauth configuration::  
* lshd-connection configuration::  

Invoking @command{lsh}

* Algorithms: Algorithm options.  Selecting algorithms.
* Hostauth options::            
* Userauth options::            
* Actions: Action options.      What to do after login.
* Gateway options::             
* Messages: Verbosity options.  Tuning the amount of messages.

@end detailmenu
@end menu

@end ifnottex

@node Introduction, Installation, Top, Top
@comment  node-name,  next,  previous,  up
@chapter Introduction

What is this thing called computer security anyway? Why would you want
to use a program like @command{lsh}?

This chapter explains the threats @command{lsh} tries to protect you from,
and some of the threats that remain. It also describes some of the
technologies used in @command{lsh}.

From time to time in this manual, I will speak about the @dfn{enemy}.
This means anybody who is trying to eavesdrop or disturb your private
communication. This usage is technical, and it does not imply that the
enemy is somehow morally inferior to you: The enemy may be some awful
criminals trying to eavesdrop on you, or it may be the police trying to
eavesdrop on the same criminals.

The enemy can be a criminal, or a competitor, or your boss who's trying
to find out how much you tell collegues at competing firms. It may be
your own or somebody else's national security officials. Or your
ex-boyfriend who happens to be too curious.

So what can the enemy do to your communications and your privacy?
Remember that just because you're paranoid that doesn't mean that nobody
is trying to get you@dots{}


@menu
* Threats::                     
* Features::                    
* Related techniques::          
@end menu

@node Threats, Features, Introduction, Introduction
@comment  node-name,  next,  previous,  up
@section Threats

When logging in to some other machine via the Internet, either in the
same building or a few continents away, there are several things that
may be under enemy attack.

@table @dfn
@item Local attacks
The enemy controls your local environment. He or she may be looking over
your shoulder. Your local machine might be cracked. Or there may be some
device planted inside your keyboard transmitting everything you type to
the attacker. About the same problems occur if the attacker has taken
control over your target machine, i.e. the remote machine you have
logged in to.

@item Denial-of-service attacks
The enemy has cut your network cable, effectively stopping your
communication. Even without doing physical damage, the enemy may be able
to flood and overload computers or network equipment. Or disrupt network
traffic by sending fake packets to hangup your @acronym{TCP/IP}
connections.

@item Passive eavesdropping
The enemy may be able to listen to your communication somewhere along
its path. With the global Internet, it's difficult to predict who might
be able to listen. Internet traffic between buildings just a few hundred
meters apart have been observed temporarily being routed through half a
dozen countries, perhaps a few thousand kilometers.

And even without routing anomalies, it is possible that the enemy has
been able to take control of some nearby machine, and can listen in from
there. Of course, passive eavesdropping is most dangerous if you
transmit cleartext passwords. This is the main reason not to use vanilla
telnet to login to remote systems. Use a telnet with support for
@acronym{SSL} or Kerberos, or use a program like @command{lsh} or
@command{ssh}. 

A passive eavesdropper is assumed not to do anything nasty with your
packets beyond listening to them.

@item Name resolution attacks
The translation from symbolic @acronym{DNS} names to numeric
ip-addresses may be controlled by the attacker. In this case, you may
think that you are connecting to a friendly machine, when in fact you
are connecting somewhere else.

@item Fake packets
It is fairly easy to fake the source address of an @acronym{IP}-packet,
although it is more difficult to get hold on the replies to the faked
packets. But even without any replies, this can cause serious
problems. 

@item Man-in-the-middle attack
In this attack, the enemy sits between you and the target. When
communicating with you, he pretends to be the target. When communicating
with the target, he pretends to be you. He also passes all information
on more or less unmodified, so that he is invisible to you and the
target. To mount this attack, the enemy either needs physical access to
some network equipment on the path between you and the target, or he has
been able to fool you to connect to him rather than to the target, for
example by manipulating the @acronym{DNS}-system.

@end table

@command{lsh} makes no attempt to protect you from local attacks. You have
to trust the endpoint machines. It seems really difficult to uphold any
security if the local machine is compromised. This is important to keep
in mind in the ``visitor''-scenario, where you visit a friend or perhaps an
Internet café and want to connect to some of the machines at home or at
work. If the enemy has been able to compromize your friend's or the
café's equipment, you may well be in trouble.

Protection from denial-of-service attacks is also a very difficult
problem, and @command{lsh} makes no attempt to protect you from that.

Instead, the aim of @command{lsh}, and most serious tools for cryptographic
protection of communications across the net, is to isolate the
vulnerabilities to the communication endpoints. If you know that the
endpoints are safe, the enemy should not be able to compromize your
privacy or communications. Except for denial-of-service attacks (which
at least can't be performed without you noticing it).

First of all, @command{lsh} provides protection against passive
eavesdropping. In addition, if you take the appropriate steps to make
sure that hostkeys are properly authenticated, @command{lsh} also protects
against man-in-the-middle attacks and in particular against attacks on
the name resolution. In short, you need only trust the security at the
end points: Even if the enemy controls all other network equipment, name
resolution and routing infrastructure, etc, he can't do anything beyond
the denial-of-service attack.

And at last, remember that there is no such thing as absolute security.
You have to estimate the value of that which you are protecting, and
adjust the security measures so that your enemies will not find it worth
the effort to break them.


@node Features, Related techniques, Threats, Introduction
@comment  node-name,  next,  previous,  up
@section Features

@command{lsh} does not only provide more secure replacements for
@command{telnet}, @command{rsh} and @command{rlogin}, it also provides
some other features to make it convenient to communicate securely. This
section is expected to grow with time, as more features from the
wish-list are added to lsh. One goal for @command{lsh} is to make it
reasonable easy to extend it, without messing with the core security
functionality.

@command{lsh} can also be used in something called gateway mode, in
which you can authenticate once and set up a connection that can
later be reused for quickly setting up new sessions.

@command{lsh} can be configured to allow login based on a personal
key-pair consisting of a private and a public key, so that you can
execute remote commands without typing your password every time.
Kerberos support and support for Thomas Wu's Secure Remote Password
Protocol (@acronym{SRP}) is on the wish list but not yet supported
(@pxref{Kerberos}).

The public-key authentication methods should also be extended to support
Simple Public Key Infrastructure (@acronym{SPKI}) certificates,
including some mechanism to delegate restricted logins.

Forwarding of arbitrary @acronym{TCP/IP} connections is provided. This
is useful for tunneling otherwise insecure protocols, like telnet and
pop, through an encrypted @command{lsh} connection.

@command{lsh} also features a @acronym{SOCKS}-proxy which also provides
tunneling of @acronym{TCP/IP} connections, but without specifying the
remote targets in advance. E.g., web browsers like Firefox can be
configured to use @acronym{SOCKS} for tunneling web traffic. There are
also programs like @command{tsocks} that performs transparent
redirection of network access through a @acronym{SOCKS} proxy.

Convenient tunneling of @acronym{X} was one of the most impressive
features of the original @command{ssh} programs. Both @command{lsh} and
@command{lshd} support @acronym{X}-forwarding.
Whan @acronym{X} forwarding is in effect, the remote process is started
in an environment where the @env{DISPLAY} variable in the environment
points to a fake @acronym{X} server, connections to which are forwarded
to the @acronym{X} server in your local environment. @command{lsh} also
creates a new ``fake'' @samp{MIT-MAGIC-COOKIE-1} for access
control. Your real @acronym{X} authentication data is never sent to the
remote machine.

Other kinds of tunneling that may turn out to be useful include
authentication (i.e. @command{ssh-agent}), general forwarding of
@acronym{UDP}, and why not also general @acronym{IP}-tunneling.


@node Related techniques,  , Features, Introduction
@comment  node-name,  next,  previous,  up
@section Related programs and techniques

This sections describes some other programs and techniques related to
@command{lsh}. The ssh family of programs use mostly the same kind of
security as @command{lsh}. Kerberos and @acronym{IPSEC} operate quite
differently, in particular when it comes to protection against
man-in-the-middle attacks.

@menu
* ssh1::                        SSH version 1
* ssh2::                        SSH version 2
* tls::                         
* Kerberos::                    Kerberos
* ipsec::                       IP Sec
@end menu

@node ssh1, ssh2, Related techniques, Related techniques
@comment  node-name,  next,  previous,  up
@subsection @code{ssh-1.x}

The first of the Secure shell programs was Tatu Ylönen's @command{ssh}.
The latest of the version 1 series is @code{ssh-1.33} which speaks
version 1.5 of the protocol. The ``free'' version of @code{ssh-1.33}
does not allow commercial use without additional licensing, which makes
@code{ssh-1.33} non-free software according to Debian's Free Software
Guidelines and the Open Source Definition.

The version 1 protocol has some subtle weaknesses, in particular, all
support for using stream ciphers was disabled by default a few versions
back, for security reasons.

There also exists free implementations of @code{ssh-1}, for both Unix
and Windows. @command{ossh} and later OpenSSH are derived from an earlier
free version av Tatu Ylönen's @command{ssh}, and are free software.

@node ssh2, tls, ssh1, Related techniques
@comment  node-name,  next,  previous,  up
@subsection @code{ssh-2.x}

@command{ssh2} implements the next generation of the Secure Shell
protocol, now specified by the @acronym{IETF}
secsh Working Group. Besides @command{lsh}, some well known
implementations of this protocol includes
@itemize
@item
OpenSSH (which supports version 2 of the protocol since May 2000).

@item
The @command{ssh2} series of proprietary programs sold by the SSH
company. @command{lsh} interoperates with current versions of these
programs, but not with version 3.0 and earlier (the older versions get
some details of the protocol wrong, probably because it predates the
protocol specification). The license for the SSH company's
@command{ssh2} programs is similar to that for recent versions of
@command{ssh1}, but with a narrower definition of ``non-commercial
use''.

@item
@command{putty}, a free @command{ssh} implementation primarily for
Microsoft Windows.

@end itemize

There a numerous other implementations, both free and proprietary. The
above list is far from complete.

@node tls, Kerberos, ssh2, Related techniques
@comment  node-name,  next,  previous,  up
@subsection TLS

Transport Layer Security, @acronym{tls}, is a protocol developed by the @acronym{ietf},
based on the earlier protocol called Secure Socket Layer, @acronym{ssl}, which was
developed by Netscape. It provides as encrypted session, which can then be
used for other protocols, such as @acronym{http}, @acronym{smtp}, and
@acronym{imap}. 

In @acronym{tls}, server authentication is usually based on x.509
certificates. x.509 certificates can be used for client authentication
as well, but it is more common to use an application specific
authentication, often using some password.

@node Kerberos, ipsec, tls, Related techniques
@comment  node-name,  next,  previous,  up
@subsection Kerberos

Kerberos is a key distribution system originally developed in the late
1980:s as a part of Project Athena at @acronym{MIT}. Recent development
have been done at The Royal Institute of Technology, Stockholm
(@acronym{KTH}).

Kerberos uses a central trusted ticket-granting server, and requires
less trust on the local machines in the system. It does not use
public-key technology.

Usually, Kerberos support is compiled into applications such as telnet,
ftp and X-clients. The ssh family of programs, on the other hand, tries
to do all needed magic, for instance to forward @acronym{X} securely,
and then provides general @acronym{TCP/IP} forwarding as a kitchen sink.

I believe Kerberos' and lsh's protection against passive eavesdropping
are mostly equivalent. The difference is in the set of machines and
assumptions you have to trust in order to be safe from a
man-in-the-middle attack.

I think the main advantage of @command{lsh} over Kerberos is that it is
easier to install and use for an ordinary mortal user. In order to set
up key exchange between two different Kerberos systems (or @dfn{Kerberos
realms}), the respective system operators need to exchange keys. In the
case of two random users at two random sites, setting up @command{lsh} or
some other program in the ssh family is likely easier than to get the
operators to spend time and attention. So @command{lsh} should be easier to
use in an anarchistic grass-roots environment.

Another perspective is to combine ssh features like @acronym{X} and
@acronym{TCP/IP} forwarding with authentication based on Kerberos. Such
an arrangement may provide the best of two worlds for those who happen
to have an account at a suitable ticket-granting server.

@node ipsec,  , Kerberos, Related techniques
@comment  node-name,  next,  previous,  up
@subsection @acronym{IPSEC}

@acronym{IPSEC} is a set of protocols for protecting general
@acronym{IP} traffic. It is developed by another @acronym{IETF} working
group, and is also a required part of @acronym{IP} version 6.

Again, the main difference between @acronym{IPSEC}, Kerberos and ssh
is the set of machines that have to be secure and the keys that have to
be exchanged in order to avoid man-in-the-middle attacks.

Current protocols and implementations of @acronym{IPSEC} only provide
authentication of machines; there's nothing analogous to the user
authentication in ssh or Kerberos.

On the other hand, @acronym{IPSEC} provides one distinct advantage over
application level encryption. Because @acronym{IP} and @acronym{TCP}
headers are authenticated, it provides protection against some
denial-of-service attacks. In particular, it makes attacks that cause
hangup of a @acronym{TCP} connection considerably more difficult.

So it makes sense to use both @acronym{IPSEC} and some application
level cryptographic protocol.

Also note that it is possible to use the @dfn{Point-to-Point Protocol}
(@acronym{PPP}) to tunnel arbitrary @acronym{IP} traffic accross an ssh
connection. This arrangement provides some of the functionality of
@acronym{IPSEC}, and is sometimes referred to as ``a poor man's Virtual
Private Network''.

@node Installation, Getting started, Introduction, Top
@comment  node-name,  next,  previous,  up
@chapter Installation

You install @command{lsh} with the usual @code{./configure && make &&
make install}. For a full listing of the options you can give to
@command{configure}, use @code{./configure --help}. For example, use
@option{--without-pty} to disable pty-support.

The most commonly used option is @option{--prefix}, which tells
configure where lsh should be installed. Default prefix is
@file{/usr/local}. The @command{lshd} server is installed in
@file{$prefix/sbin}, various helper programs are installed in
@file{$prefix/libexec}, and all other programs and scripts are
installed in @file{$prefix/bin}.

Note that by default, all lsh-related files are stored under
@file{prefix}, including configuration files, and the host key and
seed file used by the server. You may want to use
@example
./configure --sysconfdir=/etc --localstatedir=/var
@end example

@noindent
to place these files on the root and @file{/var} partitions.

The configure script tries to figure out if the linker needs any special
flags specifying where to find dynamically linked libraries at run time
(one case where this matters is if you have a dynamic libz.so installed
in a non-standard place). Usually, you can use

@example
./configure --with-lib-path=/opt/lib:/other/place
@end example

@noindent
to specify extra library directories, and the configure script should do
the right thing. If this doesn't work, or you believe that you know your
system better than @command{./configure}, just set LDFLAGS and/or
LD_LIBRARY_PATH to the right values instead.


@node Getting started, Server configuration, Installation, Top
@comment  node-name,  next,  previous,  up
@chapter Getting started
This section tells you how to perform some common tasks using the
@command{lsh} suite of programs, without covering all options and
possibilities.

@menu
* lsh-make-seed ::              Initializing the randomness generator
* lsh basics::                  Connection with lsh
* tcpip forwarding::            Forwarding @acronym{TCP/IP} ports
* lshd basics::                 Starting the lshd deamon
* public-key::                  Using public-keys
* sexp::                        Examining keys and other S-exp files
* Converting keys::             
@end menu

@node lsh-make-seed , lsh basics, Getting started, Getting started
@comment  node-name,  next,  previous,  up
@section Initializing the randomness generator

Several of the lsh programs requires a good pseudorandomness generator
for secure operation. The first thing you need to do is to create a
seed file for the generator. The personal seed file, stored as
@file{~/.lsh/yarrow-seed-file}, is created by

@example
lsh-make-seed
@end example

Client programs that need the pseudorandomness generator will offer to
run this command for you, if the seed file doesn't exist. To create a
seed file for use by @command{lshd}, run

@example
lsh-make-seed --server
@end example

as root. By default, the seed file is stored as
@file{/usr/local/var/spool/lsh/yarrow-seed-file}, this can be changed
using the @option{--localstatedir} option to configure or the
@code{LSH_YARROW_SEED_FILE} environment variable at run time.


@node lsh basics, tcpip forwarding, lsh-make-seed , Getting started
@comment  node-name,  next,  previous,  up
@section @command{lsh} basics

@command{lsh} is the program you use for connection to a remote machine. A
few examples are:

@example
lsh sara.lysator.liu.se
@end example

@noindent
Connects to @samp{sara.lysator.liu.se} and starts an interactive shell.
In this example, and in the rest of the examples in this section, lsh
will ask for your password, unless you have public-key user
authentication set up.

The first time you try to connect to a new machine, @command{lsh}
typically complains about an ``unknown host key''. This is because it
has no reason to believe that it was the right machine that answered,
and not a machine controlled by the enemy (@pxref{Threats}). The default
behaviour is to never ever accept a server that is not properly
authenticated. A machine is considered authentic if it follows the
protocol and has an acl-entry for its public hostkey listed in
@file{~/.lsh/host-acls}.

To make lsh less paranoid, use

@example
lsh --sloppy-host-authentication sara.lysator.liu.se
@end example

@noindent
Then @command{lsh} will display a @dfn{fingerprint} of the host key of
the remote machine, and ask you if it is correct. If you confirm,
@command{lsh} asks you if the host key should be remembered for the
future. If you confirm again, a corresponding acl-entry is appended to
@file{~/.lsh/host-acls}.

@c You can create fingerprints for the hostkeys you need regularly, and
@c keep with you (@pxref{sexp}).

@example
lsh -l omar sara.lysator.liu.se
@end example
or
@example
lsh omar@@sara.lysator.liu.se
@end example

@noindent
Connects, like above, but tries to log in as the user ``omar''.

@example
lsh sara.lysator.liu.se tar cf - some/dir | (cd /target/dir && tar -xf -)
@end example

Copies a directory from the remote machine, by executing one remote and
one local @command{tar} process and piping them together.

@example
CVS_RSH=lsh cvs -d cvs.lysator.liu.se:/cvsroot/lsh co lsh
@end example

@noindent
Checks out the @command{lsh} source code from the @acronym{CVS}
repository.

@example
lsh -G -B sara.lysator.liu.se
@end example

Opens an ssh connection, creates a ``gateway socket'', and forks into
the background. After this gateway is setup, the command

@example
lsh sara.lysator.liu.se
@end example

creates a new session using an existing gateway socket, without the
overhead for a new key exchange and without asking for any passwords.
Access to the gateway, an @code{AF_UNIX}-socket located under
@file{/tmp}, is restricted using the usual file permissions.

@node  tcpip forwarding, lshd basics, lsh basics, Getting started
@comment  node-name,  next,  previous,  up
@section Port forwarding

One useful feature of @command{lsh} and other ssh-like programs is the
ability to forward arbitrary connections inside the encrypted
connection. There are two flavors: ``local'' and ``remote'' forwarding.

An example of local forwarding is

@example
lsh -L 4000:kom.lysator.liu.se:4894 sara.lysator.liu.se
@end example

@noindent
This makes @command{lsh} listen on port 4000 on the @emph{local}
machine. When someone connects, @command{lsh} asks the server to open a
connection from the @emph{remote} machine (i.e. @samp{sara}) to port
4894 on another machine (i.e. @samp{kom}). The two connections are piped
together using an encrypted channel.

There are a few things that should be noted here:

@itemize @bullet
@item
By default, @command{lsh} only listens on the loopback interface, so only
clients on the same machine can use the tunnel. To listen on all
interfaces, use the @option{-g} flag.

@item
A connection through the tunnel consists of three parts:

@enumerate
@item
From a client socket to the local port (4000 in this example) that
@command{lsh} listens on.

@item
The tunnel itself, from the local machine to the tunnel endpoint,
which is @samp{sara} in this example.

@item
The connection from the tunnel endpoint to the ultimate target, in this
example from @samp{sara} to @samp{kom}.

@end enumerate

Only the middle part is protected by @command{lsh}: all data flowing
through the tunnel is sent across the first and last part @emph{in the
clear}. So forwarding doesn't offer much protection unless the tunnel
endpoint and the ultimate target machine are close to each other. They
should usually be either the same machine, or two machines connected by
a local network that is trusted.

@item
Port forwarding is very useful for traversing firewalls. Of course, you
don't need to use lsh-style forwarding just to get out, there are other
tools like HTTPTunnel for that. But @command{lsh} helps you get out
through the firewall in a secure way.

@item
Port forwarding is done in addition to anything else @command{lsh} is
doing. In the example above, a tunnel is set up, but @command{lsh} will
also start an interactive shell for you. Just as if the @option{-L}
option was not present. If this is not what you want, the @option{-N} or
@option{-B} option is for you (@pxref{Invoking lsh})
@end itemize

Remote forwarding is similar, but asks the @emph{remote} machine to
listen on a port. An example of remote forwarding is

@example
lsh -g -R 8080:localhost:80 sara.lysator.liu.se
@end example

@noindent
This asks the remote machine to listen on port 8080 (note that you are
probably not authorized to listen on port 80). Whenever someone
connects, the connection is tunnelled to your local machine, and
directed to port 80 on the same machine. Note the use of @option{-g};
the effect is to allow anybody in the world to use the tunnel to connect
to your local webserver.

The same considerations that apply to forwarded local ports apply also to
forwarded remote ports.

At last, you can use any number of @option{-L} and @option{-R} options
on the same command line.


@node lshd basics, public-key, tcpip forwarding, Getting started
@comment  node-name,  next,  previous,  up
@section @command{lshd} basics

The secure shell server functionality is split between three different
programs:
@table @command
@item lshd
The main server program. Listens for incoming connections, host
authentication, key exchange and encryption and decryption of data.
Basically, this program implements the secure shell transport layer
protocol (@acronym{rfc} 4253). It usually runs with root privileges, and
it forks a service process, usually the @command{lshd-userauth} program, to
handle the higher layers of the secure shell protocol.
@item lshd-userauth
This program is responsible for user authentication, including password
authnetication and public key authentication. The corresponding protocol
specification is (@acronym{rfc} 4252). This programs is usually started
with root privileges. If user authentication is successful, it changes
the process persona and execs another service process, usually
@command{lshd-connection}. It also spawns a helper process,
lshd-pty-helper, usually running with group @code{utmp} privileges.
@item lshd-connection
This is the program responsible for most of the features users associate
with ssh, including login sessions, remote command execution,
port forwarding, and the machinery for multiplexing multiple channels
over a single ssh connection. It runs as the logged in user.
@end table

These programs communicate with each other using unencrypted ssh
packets. Each has its own configuration file and command line options.
By default, configuration files are stored in the
@file{/usr/local/etc/lshd} directory,
this can be changed using the @option{--sysconfdir} option to configure
or the @code{LSHD_CONFIG_DIR} environment variable at run time.

By default, all features are disabled, and must be explicitly enabled to
get any useful service, either on the command line or using the
appropriate configuration file. An example configuration is compiled in.
It can be enabled using the @option{--use-example-config}, and displayed
using @option{--print-example-config}.

To try out @command{lshd}, you must first create a hostkey, by default stored in
@file{/usr/local/etc/lshd/host-key}. To do this, run

@example
lsh-keygen --server
@end example

@noindent
This will also create a file @file{/usr/local/etc/lshd/host-key.pub},
containing the corresponding public key. 

A typical command line for starting lshd in daemon mode, using the
example configuration, is simply

@example
lshd --daemonic --use-example-config
@end example

You can find init script for @command{lshd} tailored for Debian's and
RedHat's GNU/Linux systems in the @file{contrib} directory. 


@node public-key, sexp, lshd basics, Getting started
@comment  node-name,  next,  previous,  up
@section Using public-key user authentication

Public-key user authentication is a way to authenticate for login,
without having to type any passwords. There are two steps: Creating a
key pair, and authorizing the public key to the systems where you want
to log in.

To create a keypair, run

@example
lsh-keygen
@end example

@noindent
This can take some time, but in the end it creates two files
@file{~/.lsh/identity} and @file{~/.lsh/identity.pub}.

If you want to use the key to login to some other machine, say
@samp{sara}, you can do that by first copying the key,

@example
lsh sara.lysator.liu.se '>my-key.pub' < ~/.lsh/identity.pub
@end example

@noindent
then authorizing it by executing, on @samp{sara},

@example
lsh-authorize my-key.pub
@end example

By default, @command{lsh-keygen} encrypts the private key using a
passphrase. This gives you some protection if a backup tape gets into
the wrong hands, or you use NFS to access the key file in your home
directory. If you want an unencrypted key, pass the flag @option{-c
none} to @command{lsh-keygen}.

For security reasons, you should keep the private key
@file{~/.lsh/identity} secret. This is of course particularly important
if the key is unencrypted; in that case, anybody who can read the file
will be able to login in your name to any machine where the
corresponding public key is registered as an authorized key.

Naturally, you should also make sure not to authorize any keys but your
own. For instance, it is inappropriate to use an insecure mechanism such
as unauthenticated email, @code{ftp} or @code{http} to transfer your
public key to the machines where you want to authorize it.

If you have accounts on several systems, you usually create one keypair
on each of the systems, and on each system you authorize some or all of
your other public keys for login.

@node sexp, Converting keys, public-key, Getting started
@comment  node-name,  next,  previous,  up
@section Examining keys and other sexp files

Keys and most other objects @command{lsh} needs to store on disk are
represented as so called S-expressions or @dfn{sexps} for short.
S-expressions have their roots in the Lisp world, and a variant of them
in used in the Simple Public Key Infrastructure (@acronym{SPKI}).
Currently, @command{lsh}'s support for @acronym{SPKI} is quite limited,
but it uses @acronym{SPKI}'s formats for keys and Access Control Lists
(@acronym{ACL}:s).

There are several flavours of the sexp syntax:

@itemize @bullet
@item
The canonical syntax is somewhere between a text and a binary format,
and is extremely easy for programs to read and write.

@item
The transport syntax, which is suitable when embedding sexps in text
files. It is essentially the canonical representation, encoded using
base64.

@item
The advanced syntax, which is intended for humans to read and write, and
bears some resemblance to Lisp expressions.
@end itemize

To see what your @file{~/.lsh/identity.pub} file really contains, try

@example
sexp-conv < ~/.lsh/identity.pub
@end example

The @command{sexp-conv} program can also be used to computes
fingerprints. The fingerprint of a key (or any sexp, for that matter) is
simply the hash of its canonical representation. For example,

@example
sexp-conv --hash </etc/lshd/host-key.pub
@end example

This flavour of fingerprints is different from the ssh
fingerprint convention, which is based on a hash of the key expressed in
ssh wire format. To produce ssh standard fingerprints, use
@samp{lsh-export-key --fingerprint}.

@node  Converting keys,  , sexp, Getting started
@comment  node-name,  next,  previous,  up
@section Converting keys from @command{ssh2} and OpenSSH

If you are already using @command{ssh2} or OpenSSH, and have created one
or more personal keypairs, you need to convert the public keys to
@command{lsh}'s format before you can authorize them. Use the supplied
@command{ssh-conv} script,

@example
ssh-conv <openssh-key.pub >new-key.pub
@end example

You can then use the usual @command{lsh-authorize} on the converted
keys. @command{ssh-conv} supports both @acronym{DSA} and @command{RSA} keys.

Conversion of keys the other way is also possible, by using the
@command{lsh-export-key} program. It reads a public key in
the  @acronym{SPKI} format used by @command{lsh} on stdin, and writes the key in
@command{ssh2}/OpenSSH format on stdout.

If you want to use your @command{lsh} key to log in to another system
running and OpenSSH server, you can do like this:
 
@example
lsh-export-key --openssh < .lsh/identity.pub >sshkey

@end example

And on the other machine, after having somehow copied the sshkey
file, just add it to the end of your @file{authorized_keys} file:

@example
cat sshkey >> ~/.ssh/authorized_keys
@end example


@command{lsh-export-key} can also be used to check the fingerprint of
keys (just like @command{ssh-keygen}).

@example
lsh-export-key --fingerprint < /etc/lshd/host-key.pub
@end example

show the @acronym{MD5} and Bubble babble 
fingerprint of the server public key.

There are currently very limited tools for conversion of private keys.
The slightly misnamed @command{pkcs1-conv} program can be used to
convert unencrypted RSA private keys in @acronym{pkcs}#1 format, and
unencrypted DSA keys in OpenSSL's format, to the sexp format used by
@command{lsh}.

@node Server configuration, Invoking lsh, Getting started, Top
@comment  node-name,  next,  previous,  up
@chapter Server configuration

@command{lshd} is a server that accepts connections from clients
speaking the Secure Shell protocol. It is usually started automatically
when the systems boots, and runs with root privileges. However, it is
also possible to start @command{lshd} manually, and with user
privileges.

The server functionality is split between three programs,
@command{lshd}, @command{lshd-userauth}, and @command{lshd-connection},
handling the different layers of the Secure Shell protocol 
(@pxref{lshd basics}).

Each program has its own configuration file. By default,
the configuration files @file{lshd.conf}, @file{lshd-userauth.conf} and
@file{lshd-connection.conf}, and key file @file{host-key}, are stored in the
@file{/usr/local/etc/lshd} directory, this can be changed using the
@option{--sysconfdir} option to configure or the @code{LSHD_CONFIG_DIR}
environment variable at run time.

Several of the configuration file options are common to all programs.

@menu
* Configuration syntax::        
* Common options::              
* lshd configuration::          
* lshd-userauth configuration::  
* lshd-connection configuration::  
@end menu

@node Configuration syntax, Common options, Server configuration, Server configuration
@section Configuration file syntax

The configuration file syntax is fairly conventional. Comments are
introduced with a @code{#} character, and extend to the end of line. 
Most settings use the syntax @code{@var{keyword} = @var{value}}, for example
@example
  enable-core-file = yes
@end example
Each setting must start on a new line; besides this, white space is not
significant. Each keyword expect a value of a certain type, one of
@table @asis
@item Number
A non-negative decimal number, e.g., @samp{17}.
@item String
A string, typically a file name or algorithm name. Currently, there is
no quoting mechanism, so the value cannot include any white space, and it
should avoid special characters that may be used for quoting in future
versions. E.g., @samp{/etc/lshd/other-key}.
@item Boolean
The value should be one of @samp{yes} and @samp{no}.
@end table

For specifying services and sybsystems, the values includes a command
line, using the syntax:
@example
@var{keyword} @var{name} @{ @var{command} @var{args @dots{}} @} 
@end example

The @var{name}, the @var{command} and the
arguments are strings. There is currently no quoting mechanism here
either. Braces are allowed in the argument list, provided that they are
properly nested. Commands which are not absolute file names are
interpreted relative to the directory @file{/usr/local/libexec/lshd};
this can be changed using the @option{--libexecdir} option to configure
or the @code{LSHD_LIBEXEC_DIR} environment variable at run time. A
simple example:
@example
subsystem sftp = @{ sftp-server @}
@end example
A more complicated example, using nested braces,
@example
service ssh-connection = @{ 
  lshd-connection --helper-fd $(helper_fd)
  --subsystem sftp @{ sftp-server -d @}
@}
@end example
(this example is a bit silly, since it would be more natural to do the
configuration of lshd-connection in its config file, rather than as
command line options in the configuration file of the program starting
it).

@node Common options, lshd configuration, Configuration syntax, Server configuration
@section Common configuration options

All three programs, @command{lshd}, @command{lshd-userauth}, and
@command{lshd-connection}, take the following configuration options
controlling the amount of logging:

@table @code
@item log-file
Takes a filename as argument (a string). Log messages are appended to
this file.
@example
log-file = /var/log/lshd.log
@end example
@item use-syslog
This boolean option enables logging via the syslog facility. Currently,
all messages are logged at the same syslog level, NOTICE.
@item quiet
Boolean option to disable warning messages.
@item verbose
Boolean option to enable verbose messages.
@item trace
Boolean option to enable messages tracing the internal flow of control.
@item debug
Boolean option to enable logging of large amounts of debug information,
including the contents of all sent and received packets. Use with care.
@end table

@node lshd configuration, lshd-userauth configuration, Common options, Server configuration
@section @command{lshd} configuration

The main server program, @command{lshd}, takes the following
configuration options:

@table @code
@item interface
Network interface to listen on. If no interface is specified, the
default behavior is to listen on all network interfaces. The value is a
string giving the name or ip-address of the interface, optionally
followed by a colon and the port to listen on. Literal IPv6 addresses
must be enclosed in square brackets. This option can be used multiple times.

@example
interface localhost
interface example-interface:443
@end example

@item port
Port to listen on. Applies to all interfaces which are not followed by
an explicit port. The value is a string giving a service name or a
numerical port number. The default, if no port is specified, is the
standard port for the ``ssh'' service, 22.

@example
port ssh
port 80
port 443
@end example

@item hostkey
A string giving the name of the server's private key file. Default is
@file{/usr/local/etc/lshd/host-key}.

@item enable-core-file
Boolean option. By default, @command{lshd} disables core files by
setting the corresponding resource limit to zero. If this option is
enabled, the resource limit is not touched, inheriting the setting of
the parent process.
@item service
This option takes as argument the name of the service to offer, followed
by a command line in braces (@pxref{Configuration syntax}). The default,
if no service is specified, is

@example
service ssh-userauth = @{ lshd-connection --session-id $(session_id) @var{other options@dots{}} @}
@end example

where verbosity options (@option{-v}, @option{-q}, @option{--debug}, and
@option{--trace}) affecting @command{lshd} are propagated by appending
them to the command line where needed.

@end table

Currently missing are to options control the list of supported
algorithms, only command line options are available for that (see
@pxref{Algorithm options}). @c FIXME

@node lshd-userauth configuration, lshd-connection configuration, lshd configuration, Server configuration

@section @command{lshd-userauth} configuration

The @command{lshd-userauth} program takes the following configuration options:

@table @code
@item allow-password
Boolean option to allow password authentication of users. Default is no.
@item allow-public-key
Boolean option to allow public key authentication of users. Default is no.
@item allow-root-login
Boolean option, to allow authentication as the root user. Default is no.
@item service
This option takes as argument the name of the service to offer, followed
by a command line in braces (@pxref{Configuration syntax}). The default,
if no service is specified, is

@example
service ssh-connection = @{ lshd-connection --helper-fd $(helper_fd) @var{other options@dots{}} @}
@end example

where verbosity options (@option{-v}, @option{-q}, @option{--debug}, and
@option{--trace}) affecting @command{lshd} are propagated by appending
them to the command line where needed.

@end table

@node lshd-connection configuration,  , lshd-userauth configuration, Server configuration
@section @command{lshd-connection} configuration

The @command{lshd-userauth} program takes the following configuration options:

@table @code
@item allow-tcpforward
Configures support for TCP/IP forwarding. The value is one of the
following strings: ``local'', ``remote'', ``yes'', or ``no''. ``local''
means that the client can request connections to other hosts (typically
the result of the client's @option{-L} command line option), while
``remote'' means that the client can ask the server to listen for
incoming connections (typically the result of the client's @option{-R}
command line option). The values ``yes'' and ``no'' allows or disallows
both types. The default is no.
@item allow-session
Boolean option. Allows the client open a ``session'' channel (used for
running processes on the server). Default is no. Note that enabling this
option is a prerequisite for enabling any of the the following options.
@item allow-shell
Boolean option. Allows the client to start an interactive shell. Default
is no.
@item allow-exec
Boolean option. Allows the client to execute commands. Default is no.
@item allow-pty
Boolean option. Allows the client to request a pseudo tty for a session.
Default is no.
@item allow-x11
Boolean option. Allows the client to request X11 forwarding for a
session. Default is no.
@item subsystem
This option takes as argument the name of a subsystem to offer, followed
by a command line in braces (@pxref{Configuration syntax}). By default, no
subsystems are enabled and any subsystem request from the client is
denied. To enable the @code{sftp} subsystem, use

@example
subsystem sftp = @{ sftp-server @}
@end example
@end table

@node Invoking lsh, Invoking lshd, Server configuration, Top
@comment  node-name,  next,  previous,  up
@chapter Invoking @command{lsh}
@anchor{lsh-usage}

You use @command{lsh} to login to a remote machine. Basic usage is

@samp{lsh [-p @var{port number}] sara.lysator.liu.se}

which attempts to connect, login, and start an interactive shell on the
remote machine. Default @var{port number} is whatever your system's
@file{/etc/services} lists for @command{ssh}. Usually, that is port 22.

There is a plethora of options to @command{lsh}, to let you configure where
and how to connect, how to authenticate, and what you want to do once
properly logged in to the remote host. Many options have both long and
short forms. This manual does not list all variants; for a full listing
of supported options, use @samp{lsh --help}.

Note that for many of the options to @command{lsh}, the ordering of the
options on the command line is important.

@c FIXME: Say something about the escape char mechanism here
@menu
* Algorithms: Algorithm options.  Selecting algorithms.
* Hostauth options::            
* Userauth options::            
* Actions: Action options.      What to do after login.
* Gateway options::             
* Messages: Verbosity options.  Tuning the amount of messages.
@end menu

@node Algorithm options, Hostauth options, Invoking lsh, Invoking lsh
@comment  node-name,  next,  previous,  up
@section Algorithm options

Before a packet is sent, each packet can be compressed, authenticated,
and encrypted, in that order. When the packet is received, it is first
decrypted, next it is checked that it is authenticated properly, and
finally it is decompressed. The algorithms used for this are negotiated
with the peer at the other end of the connection, as a part of the
initial handshake and key exchange.

Each party provides a list of supported algorithms, and the first
algorithm listed by the client, which is also found on the server's
list, is selected. Note that this implies that order in which algorithms
are listed on the server's list doesn't matter: if several algorithms
are present on both the server's and the client's lists, it's the
client's order that determines which algorithm is selected.

Algorithms of different types, e.g. data compression and message
authentication, are negotiated independently. Furthermore, algorithms
used for transmission from the client to the server are independent of
the algorithms used for transmission from the server to the client.
There are therefore no less than six different lists that could be
configured at each end.

The command line options for lsh and lshd don't let you specify
arbitrary lists. For instance, you can't specify different preferences
for sending and receiving.

There is a set of default algorithm preferences. When you use a command
line option to say that you want to use @var{algorithm} for one of the
algorithms, the default list is replaced with a list containing the
single element @var{algorithm}. For example, if you use @option{-c
arcfour} to say that you want to use @code{arcfour} as the encryption
algorithm, the connection will either end up using @code{arcfour}, or
algorithm negotiation will fail because the peer doesn't support
@code{arcfour}.

@multitable @columnfractions 0.1 0.2 0.2 0.5
@item Option
  @tab Algorithm type @tab Default @tab
@item @option{-z} @tab Data compression
  @tab @code{none}, @code{zlib}

  @tab The default preference list supports zlib compression, but
prefers not to use it. 

@item @option{-c} @tab Encryption
  @tab @code{aes128-ctr}, @code{3dec-cbc}, @code{blowfish-cbc}, @code{arcfour}

  @tab The default encryption algorithm is aes128. The default list
includes only quite old and well studied algorithms. There is a special
algorithm name @code{all} to enable all supported encryption algorithms
(except @code{none}).

@item @option{-m} @tab Message Authentication
  @tab @code{hmac-sha1}, @code{hmac-md5}

  @tab Both supported message authentication algorithms are of the
@acronym{HMAC} family.
@end multitable

As a special case, @option{-z} with no argument changes the compression
algorithm list to @code{zlib}, @code{none}, which means that you want to
use @code{zlib} if the other end supports it. This is different from
@option{-zzlib} which causes the negotiation to fail if the other end
doesn't support @code{zlib}. A somewhat unobvious consequence of
@option{-z} having an @emph{optional} argument is that if you provide an
argument, it must follow directly after the option letter, no spaces
allowed. 


@node Hostauth options, Userauth options, Algorithm options, Invoking lsh
@comment  node-name,  next,  previous,  up
@section Host authentication options

As described earlier (@pxref{Threats}), proper authentication of the
remote host is crucial to protect the connection against
man-in-the-middle attacks. By default, @command{lsh} verifies the server's
claimed host key against the @dfn{Access Control Lists} in
@file{~/.lsh/host-acls}. If the remote host cannot be authenticated,
the connection is dropped.

The options that change this behaviour are

@table @option
@item --host-db
Specifies the location of the @acronym{ACL} file (by default
@file{~/.lsh/host-acls}).

@item --sloppy-host-authentication
Tell @command{lsh} not to drop the connection if the server's key can not
be authenticated. Instead, it displays the fingerprint of the key, and
asks if it is trusted, and if it should be remembered for the future. If
you confirm both questions, the key is added to the file
@file{~/.lsh/host-acls}. If run in quiet mode, @samp{lsh -q
--sloppy-host-authentication}, @command{lsh} connects to any host, no
questions asked (and without remembering the key for the future).

@item --strict-host-authentication
Disable sloppy operation (this is the default behaviour).

@item --host-db-update
Used together with @option{--sloppy-host-authentication}, to specify the
file which @acronym{ACL}s for new hosts are appended to.

@end table

@node Userauth options, Action options, Hostauth options, Invoking lsh
@comment  node-name,  next,  previous,  up
@section User authentication options

@table @option

@item -l
Provide a name to use when logging in. By default, the value of the
@env{LOGNAME} environment variable is used.

@item -i
Try the keys from this file to log in. By default, @command{lsh} uses
@file{~/.lsh/identity}, if it exists. It ought to be possible to use
several @option{-i} options to use more than one file, but that is
currently not implemented.

@item --no-publickey
Don't attempt to log in using public key authentication.

@end table

@node Action options, Gateway options, Userauth options, Invoking lsh
@comment  node-name,  next,  previous,  up
@section Action options

There are many things @command{lsh} can do once you are logged in. There
are two types of options that control this: @dfn{actions} and
@dfn{action modifiers}. For short options, actions use uppercase letters
and modifiers use lowercase.

For each modifier @option{--foo} there's also a negated form
@option{--no-foo}. Options can also be negated by preceding it with the
special option @option{-n}. This is mainly useful for negating short
options. For instance, use @option{-nt} to tell @command{lsh} not to
request a remote pseudo terminal. Each modifier and its negation can be
used several times on the command line. For each action, the latest
previous modifier of each pair apply.

First, the actions:

@table @option

@item -L
Requests forwarding of a local port. This option takes a mandatory
argument of the form
@var{listen-port}:@var{target-host}:@var{target-port}. This option tells
@command{lsh} to listen on @var{listen-port} on the local machine. When
someone conects to that port, @command{lsh} asks the remote server to open
a connection to @var{target-port} on @var{target-host}, and if it
succeeds, the two connections are joined together through an the
@command{lsh} connection. Both port numbers should be given in decimal.

@item -R
Requests forwarding of a remote port. It takes one mandatory argument,
just like @option{-L}. But in this case @command{lsh} asks the
@emph{remote} server to listen on @var{listen-port}. When someone
connects to the remote hosts, the server will inform the local
@command{lsh}. The local @command{lsh} then connects to @var{target-port} on
@var{target-host}.

@item -D
Requests SOCKS-style forwarding. It takes one optional argument, the
port number to use for the SOCKS proxy (default is 1080). Other
applications can then use socks version 4 or version 5, to open
outgoing connections which are forwarded via the SSH connection. Note
that for short options the port number must be in the same argument if given
(i.e. @samp{-D1080} is correct, @samp{-D 1080} is not).
 
@item -E
This option takes one mandatory argument, which is a command line to be
executed on the remote machine.

@item -S
Start an interactive shell on the remote machine. 

@item -G
Open a gateway on the local machine (@pxref{Gateway options}). A gateway
is a local socket, located under /tmp, that can be used for controlling
and using the ssh connection.

@item -N
This is a no-operation action. It inhibits the default action, which is
to start an interactive shell on the remote machine. It is useful if you
want to set up a few forwarded tunnels or a gateway, and nothing more.

@item -B
Put the client into the background after key exchange and
user authentication. Implies @option{-N}

@item --subsystem
Specifies a subsystem to connect to, implies @option{--no-pty}. Example usage:
@samp{--subsystem=sftp}

@end table

If there are trailing arguments after the name of the remote system,
this is equivalent to a @option{-E} option, with a command string
constructed by catenating all the remaining arguments, separated by
spaces. This implies that the arguments are usually expanded first by
the local shell, and then the resulting command string is interpreted
again by the remote system.

If there are no trailing arguments after the name of the remote system,
and the @option{-N} option is not given, the default action is to start
a shell on the remote machine. I.e. this is equivalent to the
@option{-S} option.

There are a few supported modifiers:

@table @option

@item -t
Request a pseudo terminal. @command{lsh} asks the remote system to allocate
a pseudo terminal. If it succeeds, the local terminal is set to raw
mode. The default behaviour is to request a pty if and only if the
local @command{lsh} process has a controlling terminal. This modifier
applies to actions that create remote processes, i.e. @option{-E} and
@option{-S}, as well as the default actions.

Currently, this option is ignored if there is no local terminal.

@item -x
Request @acronym{X} forwarding. Applies to the @option{-E} and
@option{-S} and the default actions.

@item --stdin
Redirect the stdin of a remote process from a given, local, file.
Default is to use @command{lsh}'s stdin for the first process, and
@file{/dev/null} for the rest. This option applies to the @option{-E}
and @option{-S} options as well as to the default actions. The option
applies to only one process; as soon as it is used it is reset to the
default.

@item --stdout
Redirect the stdout of a remote process to a given, local, file. Default
is to use @command{lsh}'s stdout. Like @option{--stdin}, it is reset
after it is used.

@item --stderr
Redirect the stdout of a remote process to a given, local, file.
Analogous to the @option{--stdout} option.

@item --detach
Detach from terminal at session end. FIXME: Not currently supported.

@item --write-pid
Applies to @option{-B}. Write PID of backgrounded process to stdout.

@item -e
Set the escape character (use ``none'') to disable. Default is ``~''
if a tty is allocated and ``none'' otherwise.

@item -g
Remote peers, aka global forwarding. This option applies to the
forwarding actions, i.e. @option{-L}, @option{-R} and @option{-D}. By
default, only connections to the loopback interface are forwarded. This
implies that only processes on the same machine can use the forwarded
tunnel directly. If the -g modifier is in effect, the forwarding party
will listen on @emph{all} network interfaces.

@end table

@node Gateway options, Verbosity options, Action options, Invoking lsh
@comment  node-name,  next,  previous,  up
@section Gateway options

If a gateway is setup to a remote machine, usuallly using the
@option{-G} option, @command{lsh} will reuse the same connection,
avoiding the overhead of initial keyexchange and authentication. Access
to the gateway is protected using ordinary file system permissions on
the directory where the gateway sockets are located.

The following options can be used to control starting, stopping and use
of a gateway:

@table @option
@item -G
If no gateway exists, start one (in addition to any other actions). To
setup a gateway in the background, with no other actions, use
@samp{lsh -B -G}.

@item --use-gateway
Require the use of a gateway, never ccreate a new connection. If no
gateway exists, @command{lsh} exits.

@item --no-use-gateway
Don't use any gateway, always create a new connection.

@item --start-gateway
Stop any existing gateway, then start a new one just like @option{-G}.

@item --stop-gateway
Stop any existing gateway, then exit.

@end table

@node Verbosity options,  , Gateway options, Invoking lsh
@comment  node-name,  next,  previous,  up
@section Verbosity options

These options determines what messages @command{lsh} writes on
its stderr.

@table @option

@item -q
Quiet mode. Disables all messages and all questions, except password
prompts and fatal internal errors.

@item -v
Verbose mode. Makes @command{lsh} a little more verbose. The intention is
to provide information that is useful for ordinary trouble shooting,
and makes sense also to those not familiar with @command{lsh} internals.

@item --trace
Trace mode. Prints some internal information to aid tracking
@command{lsh}'s flow of control.

@item --debug.
Debug mode. Dumps @emph{a lot} of information, including dumps of all
sent and received packets. It tries to avoid dumping highly sensitive data,
such as private keys and the contents of @code{SSH_MSG_USERAUTH_REQUEST}
messages, but you should still use it with care.

@item --log-file
This option redirects all messages to a file. Takes one mandatory
argument: The name of that file.

@end table

Note that all these options are orthogonal. If you use @option{--trace},
you usually want to add @option{-v} as well; @option{--trace} does not
do that automatically.

@node Invoking lshd, Files and environment variables, Invoking lsh, Top
@comment  node-name,  next,  previous,  up
@chapter Invoking @command{lshd}
@anchor{lshd-usage}

For complete list of options, see @code{lshd --help} and similarly for
@command{lshd-userauth} and @command{lshd-connection}. Most of the
options override the corresponding configuration file settings
(@pxref{Server configuration}). The most important command line options
for @command{lshd} are listed below.

@table @option
@item --config-file
Specifies the configuration file to use.

@item --use-example-config
Use the builtin example configuration. Don't read any configuration
file.

@item --print-example-config
Print out a config file corresponding to the example configuration, and
exit.

@item --daemonic
Enables daemonic mode. @command{lshd} forks into the background,
redirects its stdio file descriptors to @file{/dev/null}, changes its
working directory to @file{/}, and redirects any diagnostic or debugging
messages via syslog.

@command{lshd} should be able to deal with the environment it inherits
if it is started by @command{init} or @command{inetd}, but this is not
really tested.

@item --pid-file
Creates a locked pid file, to make it easier to write start and stop
scripts for @command{lshd}. The mandatory argument provides the filename.
This option is enabled by default when operating in daemonic mode, and
the default filename is @file{/usr/local/var/run/lshd.pid}.

@item --no-pid-file
Don't create any pid file.

@item --no-syslog
Disable the use of the syslog facility. Makes sense only together with
@option{--daemonic}

@item --enable-core
By default, @command{lshd} disables core dumps, to avoid leaking sensitive
information. This option changes that behaviour, and allows @command{lshd}
to dump core on fatal errors.

@item --host-key
Location of the server's private key file. By default,
@file{/usr/local/etc/lshd/host-key}.

@item --interface 
Network interface to listen on. By default, @command{lshd} listens on
all interfaces. An interface can be specified as a DNS name, a literal
IPv4 address, or a literal IPv6 address enclosed in square brackets. It
can optionally be followed by a colon and a port number or service name.
Examples: @code{--interface=localhost}, @code{--interface=1.2.3.4:443},
@code{--interface=[aaaa::bbbb]:4711}. To make @command{lshd} listen on
several interfaces at the same time, just use several
@option{--interface} options on the command line.

@item --add-interface
Like @option{--interface}, but adds the interface without overriding the
corresponding configuration file setting.

@item --port
Port to listen to. The mandatory argument is a decimal port number or a
service name. Default is "ssh", usually port 22. Applies to interfaces
for which no port is explicitly specified.

@item --add-port
Like @option{--port}, but adds the port without overriding the
corresponding configuration file setting.

@item --service
The service to offer (default is the @code{ssh-userauth} service).
Option arguments are the service name followed by a command line enclosed
in braces.

@item --add-service
Like @option{--service}, but adds the service without without overriding the
corresponding configuration file setting.

@end table

In addition, @command{lshd} accepts the same algorithm selection and
verbosity options as @command{lsh}, see @ref{Algorithm options} and
@ref{Verbosity options}.

@node Files and environment variables, Concept Index, Invoking lshd, Top
@comment  node-name,  next,  previous,  up
@chapter Files and environment variables

This chapters describes all files and all environment variables that
are used by @command{lsh}, @command{lshd}, and related programs.

There are a few environment variables that modifies the behaviour of
the @command{lsh} programs. And there are also a handful of variables
that are setup by @command{lshd} when starting user processes.

@table @env
@item DISPLAY
When @acronym{X}-forwarding is enabled, @env{DISPLAY} specifies the
local display. Used by @command{lsh}.

@item HOME
User's home directory. Determines where client programs looks for the
@file{~/.lsh} directory. When @command{lshd} starts a user program, it
sets @env{HOME} from the value in the @file{/etc/passwd} file, except
if @command{lshd} is running as an ordinary user process. In the
latter case, the new process inherits @command{lsh}'s own value of
@env{HOME}.
 
@item LOGNAME
The user's log in name. Used as the default name for logging into
remote systems. Set by @command{lshd} when starting new processes.

@item LSH_YARROW_SEED_FILE
If set, it points out the location of the seed-file for the randomness
generator. Recognized both by @command{lshd} and the client programs.

@item LSHD_CONFIG_DIR
Directory for server configuration files.

@item LSHD_LIBEXEC_DIR
Directory for server helper programs.

@item LSHD_CONF
Name of @command{lshd} configuration file.

@item LSHD_CONNECTION_CONF
Name of @command{lshd-connection} configuration file.

@item LSHD_USERAUTH_CONF
Name of @command{lshd-userauth} configuration file.

@item LSHD_UTMP
Alternative file to use for UTMP logging.

@item LSHD_WTMP
Alternative file to use for WTMP logging.

@item LSHFLAGS
If set, lsh will parse any options as had they been given on the
command line.

@item POSIXLY_CORRECT
Affects the command line parsing of programs which by default accept
options mixed with arguments.

@item SEXP_CONV
The location of the @command{sexp-conv} program. If not set, the default
@file{$prefix/bin/sexp-conv} is used.

@item SSH_CLIENT
This variable may be set by lshd for established sessions. If it is set
it consists of three parts separated by whitespace, the first part
contains the address of the connecting client. The second part
contains the tcp port used on the connecting client and the third part
contains the tcp port used on the server. Not currently implemented.

@item SSH_TTY
This variable may be set by lshd for established sessions. If it is set
it is the name of the tty allocated.

@item SHELL
User's login shell. When @command{lshd} starts a user process, it sets
@env{SHELL} to the value in @file{/etc/passwd}, unless overridden by
the @option{--login-shell} command line option.

@item TERM
The type of the local terminal. If the client requests a pty for a
remote process, the value of @env{TERM} is transferred from client to
server.

@item TMPDIR
Determines where the unix socket, used for the @command{lsh} gateway
mode (@option{-G}), is located in the filesystem.

@item TZ
Time zone. Processes started by @command{lshd} inherit the value of
this variable from the server process.

@item USER
The BSD environment variable for the user's log in name. Used by
@command{lsh} if LOGNAME is not set. Also set by @command{lshd} when
starting new processes.

@item XAUTHORITY
For X11 forwarding, used by @command{lsh} to connect to the real X
server, and set by @command{lshd} in the environment of the
corresponding session.
@end table

Files used by the lsh client, stored in the @file{~/lsh} directory:

@table @file
@item identity
Your private key file. Usually created by @samp{lsh-keygen |
lsh-writekey}. Read by @command{lsh}. Should be kept secret.

@item identity.pub
The corresponding public key. You can copy this file to other systems
in order to authorize the private key to login (@pxref{Converting
keys}). 

@item host-acls
Host keys (or more precisely, ACL:s) that lsh considers authentic.
Entries have the same format as in @file{captured_keys}.

@item yarrow-seed-file
The seed file for the randomness generator. Should be kept secret.

@end table

Files used by @command{lshd}, some of which are read from user home
directories. The default system configuration directory
@file{/usr/local/etc} can be changed using the @option{--prefix} or
@option{--sysconfdir} option to configure or the @code{LSHD_CONFIG_DIR}
environment variable at run time. The state directory
@file{/usr/local/var} can be changed using the @option{--prefix} or
@option{--localstatedir} option to configure

@table @file
@item /usr/local/etc/lshd/lshd.conf
Configuration file for @command{lshd}, relating to networking and
transport layer (see @pxref{lshd configuration}).

@item /usr/local/etc/lshd/lshd-connection.conf
Configuration file for @command{lshd-connection} (see
@pxref{lshd-connection configuration}).

@item /usr/local/etc/lshd/lshd-userauth.conf
Configuration file for @command{lshd-userauth} (see
@pxref{lshd-userauth configuration}).

@item /usr/local/etc/lshd/host-key
The server's private host key.

@item /usr/local/etc/lshd/host-key.pub
The corresponding public key.

@item /usr/local/var/spool/lsh/yarrow-seed-file
The seed-file for @command{lshd}'s randomness generator.

@item ~/.lsh/authorized_keys_sha1
This is a directory that keeps a ``database'' of keys authorized for
login. With the current implementation, a key is authorized for login
if and only if this directory contains a file with a name which is the
SHA1 hash of the key. The usual way to create files is by running the
script @command{lsh-authorize}.

@end table

@node    Concept Index,  , Files and environment variables, Top
@comment  node-name,  next,  previous,  up
@unnumbered Concept Index

@printindex cp
     
@bye
